/* tslint:disable */
/* eslint-disable */
/**
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BaseItemDto } from '../models';
// @ts-ignore
import { BaseItemDtoQueryResult } from '../models';
// @ts-ignore
import { ChannelMappingOptionsDto } from '../models';
// @ts-ignore
import { ChannelType } from '../models';
// @ts-ignore
import { GetProgramsDto } from '../models';
// @ts-ignore
import { GuideInfo } from '../models';
// @ts-ignore
import { ImageType } from '../models';
// @ts-ignore
import { ItemFields } from '../models';
// @ts-ignore
import { ListingsProviderInfo } from '../models';
// @ts-ignore
import { LiveTvInfo } from '../models';
// @ts-ignore
import { NameIdPair } from '../models';
// @ts-ignore
import { ProblemDetails } from '../models';
// @ts-ignore
import { RecordingStatus } from '../models';
// @ts-ignore
import { SeriesTimerInfoDto } from '../models';
// @ts-ignore
import { SeriesTimerInfoDtoQueryResult } from '../models';
// @ts-ignore
import { SetChannelMappingDto } from '../models';
// @ts-ignore
import { SortOrder } from '../models';
// @ts-ignore
import { TimerInfoDto } from '../models';
// @ts-ignore
import { TimerInfoDtoQueryResult } from '../models';
// @ts-ignore
import { TunerChannelMapping } from '../models';
// @ts-ignore
import { TunerHostInfo } from '../models';
// @ts-ignore
import { UNKNOWN_BASE_TYPE } from '../models';
/**
 * LiveTvApi - axios parameter creator
 * @export
 */
export const LiveTvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider: async (pw?: string, validateListings?: boolean, validateLogin?: boolean, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }

            if (validateListings !== undefined) {
                localVarQueryParameter['validateListings'] = validateListings;
            }

            if (validateLogin !== undefined) {
                localVarQueryParameter['validateLogin'] = validateLogin;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('cancelSeriesTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('cancelTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording: async (recordingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('deleteRecording', 'recordingId', recordingId)
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners: async (newDevicesOnly?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Tuners/Discover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (newDevicesOnly !== undefined) {
                localVarQueryParameter['newDevicesOnly'] = newDevicesOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discvoverTuners: async (newDevicesOnly?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Tuners/Discvover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (newDevicesOnly !== undefined) {
                localVarQueryParameter['newDevicesOnly'] = newDevicesOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (channelId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getChannel', 'channelId', channelId)
            const localVarPath = `/LiveTv/Channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions: async (providerId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (providerId !== undefined) {
                localVarQueryParameter['providerId'] = providerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer: async (programId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers/Defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (programId !== undefined) {
                localVarQueryParameter['programId'] = programId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get guid info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/GuideInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups: async (id?: string, type?: string, location?: string, country?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Lineups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile: async (recordingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('getLiveRecordingFile', 'recordingId', recordingId)
            const localVarPath = `/LiveTv/LiveRecordings/{recordingId}/stream`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile: async (streamId: string, container: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('getLiveStreamFile', 'streamId', streamId)
            // verify required parameter 'container' is not null or undefined
            assertParamExists('getLiveStreamFile', 'container', container)
            const localVarPath = `/LiveTv/LiveStreamFiles/{streamId}/stream.{container}`
                .replace(`{${"streamId"}}`, encodeURIComponent(String(streamId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {Array<string>} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels: async (type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: Array<string>, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isLiked !== undefined) {
                localVarQueryParameter['isLiked'] = isLiked;
            }

            if (isDisliked !== undefined) {
                localVarQueryParameter['isDisliked'] = isDisliked;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (enableFavoriteSorting !== undefined) {
                localVarQueryParameter['enableFavoriteSorting'] = enableFavoriteSorting;
            }

            if (addCurrentProgram !== undefined) {
                localVarQueryParameter['addCurrentProgram'] = addCurrentProgram;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {Array<string>} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<string>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {Array<SortOrder>} [sortOrder] Sort Order - Ascending,Descending.
         * @param {Array<string>} [genres] The genres to return guide information for.
         * @param {Array<string>} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms: async (channelIds?: Array<string>, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: Array<string>, sortOrder?: Array<SortOrder>, genres?: Array<string>, genreIds?: Array<string>, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (channelIds) {
                localVarQueryParameter['channelIds'] = channelIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (minStartDate !== undefined) {
                localVarQueryParameter['minStartDate'] = (minStartDate as any instanceof Date) ?
                    (minStartDate as any).toISOString() :
                    minStartDate;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (maxStartDate !== undefined) {
                localVarQueryParameter['maxStartDate'] = (maxStartDate as any instanceof Date) ?
                    (maxStartDate as any).toISOString() :
                    maxStartDate;
            }

            if (minEndDate !== undefined) {
                localVarQueryParameter['minEndDate'] = (minEndDate as any instanceof Date) ?
                    (minEndDate as any).toISOString() :
                    minEndDate;
            }

            if (maxEndDate !== undefined) {
                localVarQueryParameter['maxEndDate'] = (maxEndDate as any instanceof Date) ?
                    (maxEndDate as any).toISOString() :
                    maxEndDate;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (genres) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (librarySeriesId !== undefined) {
                localVarQueryParameter['librarySeriesId'] = librarySeriesId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram: async (programId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgram', 'programId', programId)
            const localVarPath = `/LiveTv/Programs/{programId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<string>} [genreIds] The genres to return guide information for.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms: async (userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: Array<string>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs/Recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (genreIds) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording: async (recordingId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('getRecording', 'recordingId', recordingId)
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getRecordingGroup', 'groupId', groupId)
            const localVarPath = `/LiveTv/Recordings/Groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroups: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings: async (channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isLibraryItem !== undefined) {
                localVarQueryParameter['isLibraryItem'] = isLibraryItem;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingsSeries: async (channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/SchedulesDirect/Countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('getSeriesTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers: async (sortBy?: string, sortOrder?: SortOrder, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('getTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers: async (channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (isScheduled !== undefined) {
                localVarQueryParameter['isScheduled'] = isScheduled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts/Types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner: async (tunerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunerId' is not null or undefined
            assertParamExists('resetTuner', 'tunerId', tunerId)
            const localVarPath = `/LiveTv/Tuners/{tunerId}/Reset`
                .replace(`{${"tunerId"}}`, encodeURIComponent(String(tunerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE The set channel mapping dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping: async (uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            assertParamExists('setChannelMapping', 'uNKNOWNBASETYPE', uNKNOWNBASETYPE)
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer: async (timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('updateSeriesTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer: async (timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('updateTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "X-Emby-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveTvApi - functional programming interface
 * @export
 */
export const LiveTvApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiveTvApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addListingProvider(pw, validateListings, validateLogin, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTunerHost(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerHostInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTunerHost(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSeriesTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSeriesTimer(timerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTimer(timerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSeriesTimer(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSeriesTimer(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimer(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTimer(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListingProvider(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteListingProvider(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecording(recordingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecording(recordingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTunerHost(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTunerHost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverTuners(newDevicesOnly?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TunerHostInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverTuners(newDevicesOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discvoverTuners(newDevicesOnly?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TunerHostInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discvoverTuners(newDevicesOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(channelId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannel(channelId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelMappingOptions(providerId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelMappingOptionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelMappingOptions(providerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultListingProvider(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultListingProvider(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultTimer(programId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultTimer(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get guid info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuideInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuideInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuideInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLineups(id?: string, type?: string, location?: string, country?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLineups(id, type, location, country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveRecordingFile(recordingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveRecordingFile(recordingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveStreamFile(streamId: string, container: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveStreamFile(streamId, container, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {Array<string>} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: Array<string>, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveTvInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {Array<string>} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<string>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {Array<SortOrder>} [sortOrder] Sort Order - Ascending,Descending.
         * @param {Array<string>} [genres] The genres to return guide information for.
         * @param {Array<string>} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvPrograms(channelIds?: Array<string>, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: Array<string>, sortOrder?: Array<SortOrder>, genres?: Array<string>, genreIds?: Array<string>, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgram(programId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgram(programId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrograms(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrograms(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<string>} [genreIds] The genres to return guide information for.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: Array<string>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecording(recordingId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecording(recordingId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingFolders(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingFolders(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingGroups(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingGroups(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedulesDirectCountries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedulesDirectCountries(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSeriesTimer(timerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSeriesTimers(sortBy, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimer(timerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimers(channelId, seriesTimerId, isActive, isScheduled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTunerHostTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTunerHostTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetTuner(tunerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetTuner(tunerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE The set channel mapping dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setChannelMapping(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerChannelMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setChannelMapping(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSeriesTimer(timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSeriesTimer(timerId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimer(timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTimer(timerId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LiveTvApi - factory interface
 * @export
 */
export const LiveTvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiveTvApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<ListingsProviderInfo> {
            return localVarFp.addListingProvider(pw, validateListings, validateLogin, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<TunerHostInfo> {
            return localVarFp.addTunerHost(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer(timerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelSeriesTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer(timerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void> {
            return localVarFp.createSeriesTimer(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void> {
            return localVarFp.createTimer(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider(id?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteListingProvider(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording(recordingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRecording(recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost(id?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTunerHost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners(newDevicesOnly?: boolean, options?: any): AxiosPromise<Array<TunerHostInfo>> {
            return localVarFp.discoverTuners(newDevicesOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discvoverTuners(newDevicesOnly?: boolean, options?: any): AxiosPromise<Array<TunerHostInfo>> {
            return localVarFp.discvoverTuners(newDevicesOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return localVarFp.getChannel(channelId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions(providerId?: string, options?: any): AxiosPromise<ChannelMappingOptionsDto> {
            return localVarFp.getChannelMappingOptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider(options?: any): AxiosPromise<ListingsProviderInfo> {
            return localVarFp.getDefaultListingProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer(programId?: string, options?: any): AxiosPromise<SeriesTimerInfoDto> {
            return localVarFp.getDefaultTimer(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get guid info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo(options?: any): AxiosPromise<GuideInfo> {
            return localVarFp.getGuideInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups(id?: string, type?: string, location?: string, country?: string, options?: any): AxiosPromise<Array<NameIdPair>> {
            return localVarFp.getLineups(id, type, location, country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile(recordingId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getLiveRecordingFile(recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile(streamId: string, container: string, options?: any): AxiosPromise<any> {
            return localVarFp.getLiveStreamFile(streamId, container, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {Array<string>} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: Array<string>, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo(options?: any): AxiosPromise<LiveTvInfo> {
            return localVarFp.getLiveTvInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {Array<string>} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<string>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {Array<SortOrder>} [sortOrder] Sort Order - Ascending,Descending.
         * @param {Array<string>} [genres] The genres to return guide information for.
         * @param {Array<string>} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms(channelIds?: Array<string>, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: Array<string>, sortOrder?: Array<SortOrder>, genres?: Array<string>, genreIds?: Array<string>, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram(programId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return localVarFp.getProgram(programId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getPrograms(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<string>} [genreIds] The genres to return guide information for.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: Array<string>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording(recordingId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return localVarFp.getRecording(recordingId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecordingFolders(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroup(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRecordingGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroups(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecordingGroups(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries(options?: any): AxiosPromise<any> {
            return localVarFp.getSchedulesDirectCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer(timerId: string, options?: any): AxiosPromise<SeriesTimerInfoDto> {
            return localVarFp.getSeriesTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any): AxiosPromise<SeriesTimerInfoDtoQueryResult> {
            return localVarFp.getSeriesTimers(sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer(timerId: string, options?: any): AxiosPromise<TimerInfoDto> {
            return localVarFp.getTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any): AxiosPromise<TimerInfoDtoQueryResult> {
            return localVarFp.getTimers(channelId, seriesTimerId, isActive, isScheduled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes(options?: any): AxiosPromise<Array<NameIdPair>> {
            return localVarFp.getTunerHostTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner(tunerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.resetTuner(tunerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE The set channel mapping dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<TunerChannelMapping> {
            return localVarFp.setChannelMapping(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer(timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void> {
            return localVarFp.updateSeriesTimer(timerId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer(timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void> {
            return localVarFp.updateTimer(timerId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveTvApi - interface
 * @export
 * @interface LiveTvApi
 */
export interface LiveTvApiInterface {
    /**
     * 
     * @summary Adds a listings provider.
     * @param {string} [pw] Password.
     * @param {boolean} [validateListings] Validate listings.
     * @param {boolean} [validateLogin] Validate login.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New listings info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<ListingsProviderInfo>;

    /**
     * 
     * @summary Adds a tuner host.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New tuner host.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    addTunerHost(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<TunerHostInfo>;

    /**
     * 
     * @summary Cancels a live tv series timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    cancelSeriesTimer(timerId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Cancels a live tv timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    cancelTimer(timerId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Creates a live tv series timer.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    createSeriesTimer(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Creates a live tv timer.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    createTimer(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Delete listing provider.
     * @param {string} [id] Listing provider id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    deleteListingProvider(id?: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Deletes a live tv recording.
     * @param {string} recordingId Recording id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    deleteRecording(recordingId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Deletes a tuner host.
     * @param {string} [id] Tuner host id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    deleteTunerHost(id?: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Discover tuners.
     * @param {boolean} [newDevicesOnly] Only discover new tuners.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    discoverTuners(newDevicesOnly?: boolean, options?: any): AxiosPromise<Array<TunerHostInfo>>;

    /**
     * 
     * @summary Discover tuners.
     * @param {boolean} [newDevicesOnly] Only discover new tuners.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    discvoverTuners(newDevicesOnly?: boolean, options?: any): AxiosPromise<Array<TunerHostInfo>>;

    /**
     * 
     * @summary Gets a live tv channel.
     * @param {string} channelId Channel id.
     * @param {string} [userId] Optional. Attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getChannel(channelId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto>;

    /**
     * 
     * @summary Get channel mapping options.
     * @param {string} [providerId] Provider id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getChannelMappingOptions(providerId?: string, options?: any): AxiosPromise<ChannelMappingOptionsDto>;

    /**
     * 
     * @summary Gets default listings provider info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getDefaultListingProvider(options?: any): AxiosPromise<ListingsProviderInfo>;

    /**
     * 
     * @summary Gets the default values for a new timer.
     * @param {string} [programId] Optional. To attach default values based on a program.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getDefaultTimer(programId?: string, options?: any): AxiosPromise<SeriesTimerInfoDto>;

    /**
     * 
     * @summary Get guid info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getGuideInfo(options?: any): AxiosPromise<GuideInfo>;

    /**
     * 
     * @summary Gets available lineups.
     * @param {string} [id] Provider id.
     * @param {string} [type] Provider type.
     * @param {string} [location] Location.
     * @param {string} [country] Country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getLineups(id?: string, type?: string, location?: string, country?: string, options?: any): AxiosPromise<Array<NameIdPair>>;

    /**
     * 
     * @summary Gets a live tv recording stream.
     * @param {string} recordingId Recording id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getLiveRecordingFile(recordingId: string, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Gets a live tv channel stream.
     * @param {string} streamId Stream id.
     * @param {string} container Container type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getLiveStreamFile(streamId: string, container: string, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Gets available live tv channels.
     * @param {ChannelType} [type] Optional. Filter by channel type.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
     * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
     * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {Array<string>} [sortBy] Optional. Key to sort by.
     * @param {SortOrder} [sortOrder] Optional. Sort order.
     * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
     * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: Array<string>, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult>;

    /**
     * 
     * @summary Gets available live tv services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getLiveTvInfo(options?: any): AxiosPromise<LiveTvInfo>;

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {Array<string>} [channelIds] The channels to return guide information for.
     * @param {string} [userId] Optional. Filter by user id.
     * @param {string} [minStartDate] Optional. The minimum premiere start date.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
     * @param {string} [maxStartDate] Optional. The maximum premiere start date.
     * @param {string} [minEndDate] Optional. The minimum premiere end date.
     * @param {string} [maxEndDate] Optional. The maximum premiere end date.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {Array<string>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
     * @param {Array<SortOrder>} [sortOrder] Sort Order - Ascending,Descending.
     * @param {Array<string>} [genres] The genres to return guide information for.
     * @param {Array<string>} [genreIds] The genre ids to return guide information for.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {string} [seriesTimerId] Optional. Filter by series timer id.
     * @param {string} [librarySeriesId] Optional. Filter by library series id.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getLiveTvPrograms(channelIds?: Array<string>, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: Array<string>, sortOrder?: Array<SortOrder>, genres?: Array<string>, genreIds?: Array<string>, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult>;

    /**
     * 
     * @summary Gets a live tv program.
     * @param {string} programId Program id.
     * @param {string} [userId] Optional. Attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getProgram(programId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto>;

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] Request body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getPrograms(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<BaseItemDtoQueryResult>;

    /**
     * 
     * @summary Gets recommended live tv epgs.
     * @param {string} [userId] Optional. filter by user id.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
     * @param {Array<string>} [genreIds] The genres to return guide information for.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableUserData] Optional. include user data.
     * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: Array<string>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult>;

    /**
     * 
     * @summary Gets a live tv recording.
     * @param {string} recordingId Recording id.
     * @param {string} [userId] Optional. Attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getRecording(recordingId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto>;

    /**
     * 
     * @summary Gets recording folders.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getRecordingFolders(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult>;

    /**
     * 
     * @summary Get recording group.
     * @param {string} groupId Group id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getRecordingGroup(groupId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Gets live tv recording groups.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getRecordingGroups(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult>;

    /**
     * 
     * @summary Gets live tv recordings.
     * @param {string} [channelId] Optional. Filter by channel id.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {RecordingStatus} [status] Optional. Filter by recording status.
     * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
     * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
     * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult>;

    /**
     * 
     * @summary Gets live tv recording series.
     * @param {string} [channelId] Optional. Filter by channel id.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {string} [groupId] Optional. Filter by recording group.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {RecordingStatus} [status] Optional. Filter by recording status.
     * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
     * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult>;

    /**
     * 
     * @summary Gets available countries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getSchedulesDirectCountries(options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Gets a live tv series timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getSeriesTimer(timerId: string, options?: any): AxiosPromise<SeriesTimerInfoDto>;

    /**
     * 
     * @summary Gets live tv series timers.
     * @param {string} [sortBy] Optional. Sort by SortName or Priority.
     * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any): AxiosPromise<SeriesTimerInfoDtoQueryResult>;

    /**
     * 
     * @summary Gets a timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getTimer(timerId: string, options?: any): AxiosPromise<TimerInfoDto>;

    /**
     * 
     * @summary Gets the live tv timers.
     * @param {string} [channelId] Optional. Filter by channel id.
     * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
     * @param {boolean} [isActive] Optional. Filter by timers that are active.
     * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any): AxiosPromise<TimerInfoDtoQueryResult>;

    /**
     * 
     * @summary Get tuner host types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    getTunerHostTypes(options?: any): AxiosPromise<Array<NameIdPair>>;

    /**
     * 
     * @summary Resets a tv tuner.
     * @param {string} tunerId Tuner id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    resetTuner(tunerId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Set channel mappings.
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE The set channel mapping dto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    setChannelMapping(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<TunerChannelMapping>;

    /**
     * 
     * @summary Updates a live tv series timer.
     * @param {string} timerId Timer id.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    updateSeriesTimer(timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Updates a live tv timer.
     * @param {string} timerId Timer id.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApiInterface
     */
    updateTimer(timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void>;

}

/**
 * LiveTvApi - object-oriented interface
 * @export
 * @class LiveTvApi
 * @extends {BaseAPI}
 */
export class LiveTvApi extends BaseAPI implements LiveTvApiInterface {
    /**
     * 
     * @summary Adds a listings provider.
     * @param {string} [pw] Password.
     * @param {boolean} [validateListings] Validate listings.
     * @param {boolean} [validateLogin] Validate login.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New listings info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any) {
        return LiveTvApiFp(this.configuration).addListingProvider(pw, validateListings, validateLogin, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a tuner host.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New tuner host.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addTunerHost(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any) {
        return LiveTvApiFp(this.configuration).addTunerHost(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a live tv series timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelSeriesTimer(timerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).cancelSeriesTimer(timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a live tv timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelTimer(timerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).cancelTimer(timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a live tv series timer.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createSeriesTimer(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any) {
        return LiveTvApiFp(this.configuration).createSeriesTimer(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a live tv timer.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createTimer(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any) {
        return LiveTvApiFp(this.configuration).createTimer(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete listing provider.
     * @param {string} [id] Listing provider id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteListingProvider(id?: string, options?: any) {
        return LiveTvApiFp(this.configuration).deleteListingProvider(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a live tv recording.
     * @param {string} recordingId Recording id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteRecording(recordingId: string, options?: any) {
        return LiveTvApiFp(this.configuration).deleteRecording(recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a tuner host.
     * @param {string} [id] Tuner host id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteTunerHost(id?: string, options?: any) {
        return LiveTvApiFp(this.configuration).deleteTunerHost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Discover tuners.
     * @param {boolean} [newDevicesOnly] Only discover new tuners.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public discoverTuners(newDevicesOnly?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).discoverTuners(newDevicesOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Discover tuners.
     * @param {boolean} [newDevicesOnly] Only discover new tuners.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public discvoverTuners(newDevicesOnly?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).discvoverTuners(newDevicesOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv channel.
     * @param {string} channelId Channel id.
     * @param {string} [userId] Optional. Attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannel(channelId: string, userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getChannel(channelId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel mapping options.
     * @param {string} [providerId] Provider id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannelMappingOptions(providerId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getChannelMappingOptions(providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets default listings provider info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultListingProvider(options?: any) {
        return LiveTvApiFp(this.configuration).getDefaultListingProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the default values for a new timer.
     * @param {string} [programId] Optional. To attach default values based on a program.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultTimer(programId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getDefaultTimer(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get guid info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getGuideInfo(options?: any) {
        return LiveTvApiFp(this.configuration).getGuideInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available lineups.
     * @param {string} [id] Provider id.
     * @param {string} [type] Provider type.
     * @param {string} [location] Location.
     * @param {string} [country] Country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLineups(id?: string, type?: string, location?: string, country?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getLineups(id, type, location, country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv recording stream.
     * @param {string} recordingId Recording id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveRecordingFile(recordingId: string, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveRecordingFile(recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv channel stream.
     * @param {string} streamId Stream id.
     * @param {string} container Container type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveStreamFile(streamId: string, container: string, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveStreamFile(streamId, container, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv channels.
     * @param {ChannelType} [type] Optional. Filter by channel type.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
     * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
     * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {Array<string>} [sortBy] Optional. Key to sort by.
     * @param {SortOrder} [sortOrder] Optional. Sort order.
     * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
     * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: Array<string>, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvInfo(options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {Array<string>} [channelIds] The channels to return guide information for.
     * @param {string} [userId] Optional. Filter by user id.
     * @param {string} [minStartDate] Optional. The minimum premiere start date.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
     * @param {string} [maxStartDate] Optional. The maximum premiere start date.
     * @param {string} [minEndDate] Optional. The minimum premiere end date.
     * @param {string} [maxEndDate] Optional. The maximum premiere end date.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {Array<string>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
     * @param {Array<SortOrder>} [sortOrder] Sort Order - Ascending,Descending.
     * @param {Array<string>} [genres] The genres to return guide information for.
     * @param {Array<string>} [genreIds] The genre ids to return guide information for.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {string} [seriesTimerId] Optional. Filter by series timer id.
     * @param {string} [librarySeriesId] Optional. Filter by library series id.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvPrograms(channelIds?: Array<string>, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: Array<string>, sortOrder?: Array<SortOrder>, genres?: Array<string>, genreIds?: Array<string>, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv program.
     * @param {string} programId Program id.
     * @param {string} [userId] Optional. Attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getProgram(programId: string, userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getProgram(programId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] Request body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getPrograms(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any) {
        return LiveTvApiFp(this.configuration).getPrograms(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets recommended live tv epgs.
     * @param {string} [userId] Optional. filter by user id.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
     * @param {Array<string>} [genreIds] The genres to return guide information for.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableUserData] Optional. include user data.
     * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: Array<string>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv recording.
     * @param {string} recordingId Recording id.
     * @param {string} [userId] Optional. Attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecording(recordingId: string, userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getRecording(recordingId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets recording folders.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingFolders(userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingFolders(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recording group.
     * @param {string} groupId Group id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroup(groupId: string, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recording groups.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroups(userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingGroups(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recordings.
     * @param {string} [channelId] Optional. Filter by channel id.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {RecordingStatus} [status] Optional. Filter by recording status.
     * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
     * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
     * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recording series.
     * @param {string} [channelId] Optional. Filter by channel id.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {string} [groupId] Optional. Filter by recording group.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {RecordingStatus} [status] Optional. Filter by recording status.
     * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
     * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
     * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available countries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSchedulesDirectCountries(options?: any) {
        return LiveTvApiFp(this.configuration).getSchedulesDirectCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv series timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimer(timerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).getSeriesTimer(timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv series timers.
     * @param {string} [sortBy] Optional. Sort by SortName or Priority.
     * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any) {
        return LiveTvApiFp(this.configuration).getSeriesTimers(sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimer(timerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).getTimer(timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the live tv timers.
     * @param {string} [channelId] Optional. Filter by channel id.
     * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
     * @param {boolean} [isActive] Optional. Filter by timers that are active.
     * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getTimers(channelId, seriesTimerId, isActive, isScheduled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tuner host types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTunerHostTypes(options?: any) {
        return LiveTvApiFp(this.configuration).getTunerHostTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resets a tv tuner.
     * @param {string} tunerId Tuner id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public resetTuner(tunerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).resetTuner(tunerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set channel mappings.
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE The set channel mapping dto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public setChannelMapping(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any) {
        return LiveTvApiFp(this.configuration).setChannelMapping(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a live tv series timer.
     * @param {string} timerId Timer id.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New series timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateSeriesTimer(timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any) {
        return LiveTvApiFp(this.configuration).updateSeriesTimer(timerId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a live tv timer.
     * @param {string} timerId Timer id.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] New timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateTimer(timerId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any) {
        return LiveTvApiFp(this.configuration).updateTimer(timerId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}
